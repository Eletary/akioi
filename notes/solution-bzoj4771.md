# 七彩树 题解

让我们先解决几个问题。

## 树链问题

当树是一条链时，问题变为区间问题。

设结点的下标为其深度，对于每一个点，开一棵线段树维护这样的序列。

在父亲线段树的基础上，在当前结点下标上加一，同时在上一次出现该结点值的地方减一。

查询时在下标为 $dep_x+d$ 的那棵线段树上查询 $[x,n+1)$ 即可。

可以用主席树实现。

（SDOI2009 HH的项链）

我们发现，其实**查询 $[l,r+1)$ 就够了**。

## 子树问题

每次询问的深度都充分大时，问题变为询问一个子树的问题。

我们扩展上面的做法。观察发现一棵子树在 dfs 序上连续，从而把问题转化为 dfs 序上的区间问题。

## 原问题

这样的询问无法像上面那样转化为区间问题了。

不过可以这么考虑：如果先更新深度小的线段树再更新大的，那岂不是说在一棵树上**查询任何区间的答案都只统计到当前深度**？

所以我们按 bfs 序去刷新线段树，但是线段树内仍维护 dfs 序，查询时查询**待查集合内 dfs 序最靠后的结点就行了**？

所以思路就是，线段树上维护 dfs 序，但是每个结点从 bfs 序的前一个更新而来，每次颜色相同的、dfs 序上和它距离最小的结点减一。查询的时候在子树内深度 $\leq dep_x+d$ 且在 dfs 序上最靠后的那棵线段树上查询以 $x$ 为根的子树这段 dfs 序即可。

不好意思，错了。

```
6 1
1 2 3 3 4 5
1 2 1 4 4
4 2
```

这时候是这样一棵树：

![树的示意图]()

每个结点上线段树的值：

```
// bfs序
1: 100000
2: 110000
4: 110100
3: 111000
5: 111010
6: 111011
```

查询的是结点 $6$ 上的 $[4,6+1)$（按照 dfs 序），答案为 $2$。

事实上，是 $3$ 号结点抹掉了 $4$ 号结点的值。

仔细想想，其实询问同时包含两个结点时，才需要减一。

而同时包含两个结点的，最深是它们的 LCA。

就酱。